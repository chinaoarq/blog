# 接口安全详细设计

本文档内容可以氛围两大部分：**实现接口安全的手段**、**现有接口梳理**。

* 第一部分，介绍了**基本规范**、**认证&授权**、**安全限制**、**安全保障**四种手段，其中认证&授权是重中之重，所占篇幅最多。在设计与实现接口时进行灵活使用这些手段，既可满足绝大部分使用场景的安全要求 
* 第二部分，梳理系统中各个项目的接口，确定每个接口需要达到的安全水平，及实现此安全需采用的手段

## 基本规范

### HTTP协议
* 查询类接口一律使用`GET`
* 增删改类接口一律使用`POST`
* 请求参数缺失时，返回`400 Bad Request`
* TOKEN校验失败时，返回`401 Unauthorized`
* 权限不够时，返回`403 Forbidden`
* 请求过于频繁时，返回`429 Too Many Requests` with `Retry-After`
* 各公网WEB接口`CORS`配置，应为只允许自有系统域名跨域访问

### 请求参数校验
所有接口应做以下三类参数校验：
* 参数格式校验（比如字段为空、手机号格式错误等）
* 业务规则校验（比如用户修改接口不允许身份证号冲突、试卷批改接口不允许设置大于总分的得分等）
* 水平越权校验（隶属于用户个人的页面或者功能必须进行权限控制校验，比如学生查看不属于自己的试卷详情）

### Response Body
* 默认返回JSONResult格式
* 请求受理过程未出错的接口，HR应返回S_OK（查询类接口如果没有匹配的结果，也返回S_OK）
* 请求参数不符合业务要求时，HR返回E_INVALID_PARAM，Message提示具体错误原因
* response不应泄漏敏感信息  
  `比如短信验证码登陆时，接口不能返回说当前手机号尚未注册，否则会暴露出系统所有用户的手机号；  
  再比如账号密码登陆时，不应准确提示'账号不存在'或提示'密码错误'，而应笼统的提示账号或密码错误`


## 认证&授权

### 0、AuthFree
此类接口无需认证授权

### 1、调用方提供私有信息（口令）
考虑以下场景：
* 用户登录
* 成教录取学生进行人像采集&身份认证（成教录取学生在青书学堂没有账号）
* 成教学生在线支付学费（学校要求的支付体验中没有登陆青书学堂这一步）

此场景的特点即**接口调用者是不能事先登陆青书学堂的终端用户**，我们也不能采用调用方提供SIGN的方式实现安全（因为签名动作在CLIENT端不安全）。

针对这种场景，我们可以让调用方提供私有信息方式实现认证授权，具体步骤如下：
1. 在真正提供服务之前（比如允许成教学生上传照片进行人脸对比之前、允许成教在线缴费学生在青书学堂下单之前）先让用户输入一些私有的信息证明其身份（比如账号密码、所属学校+学号+身份证号等）
2. 私有信息验证通过后，SERVER发送给调用方一个`RBAC BASED TOKEN`，后续的接口调用需带上该token作为认证授权凭证，下文会详细讲解`RBAC BASED TOEKN`

> 使用此种认证的接口，一般需配合`TempDeniedWhenTooManyError`安全限制防止暴力攻击，详见下文安全限制部分

### 2、调用方提供RBAC BASED TOKEN
承接上步，当用户提供的信息可信，server要为其分配token作为后续请求的认证授权凭证。为了完成认证和授权两个工作，server需要能够根据token内容回答以下问题：
1. token对应的用户是谁？（认证）
2. 这个用户具有什么权限，是否有权执行当前请求？（授权）

认证的问题比较好解决，只要在token中存放userId即可。对于授权，业界比较成熟的方法是使用[RBAC(AuthRole-based access control)](https://en.wikipedia.org/wiki/AuthRole-based_access_control)
模型，将用户按角色分组，再为组配置可执行权限。RBAC避免了权限配置爆炸的问题。使用token进行认证授权最重要的工作就是确定系统角色与权限，至于加密方式、存储方式、实现框架等都是次要的。

#### token内容设计
server使用[JWT](https://jwt.io)规范生成token，格式如下：
```JavaScript
// HEADER
{
    "alg": "HS256",
    "typ": "JWT"
}
```
```JavaScript
// PAYLOAD
{
    // 所有token包含以下字段，可以称之为BasicClaims
    "jti": "ss23jo23o24k234",   // jwtId，需唯一，用于判断此token是否已经被置为无效
    "exp": 1292348349520423,    // 自动失效时间
    "client": "APP",            // 可选：Android, IOS, WEB, MSITE, WXAPP
    "uId": 12312,               // 可能为空
    "role": 100,                // 可选值：0匿名用户 1弱密码用户 2未绑定手机用户 3成考录取人脸验证学生 100普通用户
    
    // 以下部分，可以称之为DynamicClaims，字段根据role不同有所不同
    "schoolId": 13,             // 仅当role==3时，存放录取学校
    "orgs": [                   // 仅当role==100，存放用户所属origination，比如某学校、教师平台、云享课、青书大学
        {
            "id": 12312,        // 组织id
            "type": "dg",       // 组织类型，可选值：dg, gz, px, tp, hsz, qsdx, dgexam
            "ouId": 2004433,    // 用户在该组织中的ID，可空，比如云享课等组织使用的是globalUserId
            "roles": [2,4]      // 用户在该组织中的角色，可选值：1学生 2学校教学老师 3函授站教务老师 4学校教务老师 8函授站教学老师
        }
    ]
}
```
JWT存放在client端，每次请求时client使用http header携带。server不存用户token信息，这样可以让server架构更加简单、无状态。

#### token角色
```java
/**
 * 按大类划分的token角色
 * 
 * 根据业务需要，可以在0～99添加新角色，比如DGStudentTuitionPay代表不登陆青书学堂的情况下支付成教学费的学生
 * 
 * <b>认证授权时使用的角色，会写入token，修改此类时不能改变已有角色</b>
 */
enum TokenAuthRole implements AuthRole {
    AnonymousUser(0),
    WeakPwdUser(1),
    NeedBindPhone(2),
    /**
     * 进行成教录取身份确认的学生（这些学生还不是青书学堂用户）
     */
    DGStudentAdmissionVerify(3),

    /**
     * 普通用户，即已登陆且无特殊状态（比如WeakPwdUser即特殊状态）的青书学堂用户
     */
    CommonUser(100)
}

/**
 * 普通用户的细分角色
 * 
 * 角色之间具有继承关系，继承关系体现在授权校验时。比如在ModuleAuthorizationRuleManager配置某url可以Teacher访问，那么所有Teacher的children也都可以访问
 * 根据业务需要，可以在此角色树上自由扩展新的角色，但要注意parent/children的自然合理性
 * 
 * **此类的角色值不能在认证时写入token，不然某些场景中会存在授权问题**，比如：
 * 一个高职老师登陆时，此类还没有GZTeacher这个角色，所以token只能写入Teacher角色，
 * 然后系统代码进行类升级，此类加了GZTeacher这个角色，并且配置了一些功能只有GZTeacher可以使用，此时，之前为高职老师生成的token不能使用这些功能
 */
enum CommonUserConcreteRole implements AuthRole {
    Teacher(1001, null),
    DGTeacher(10011, Teacher),
    DGCenterTeacher(100111, DGTeacher),
    DGExamTeacher(100112, DGTeacher),
    Student(1002, null),
    DGStudent(10021, Student),
    QSDXStudent(10022, Student);

    private int role;
    private CommonUserConcreteRole parent;

    AuthRole(int role, CommonUserConcreteRole parent){
        this.role = role;
        this.parent = parent;
    }
}
```

#### token生成与校验

```java
/**
 * 用户身份凭证，可由token反序列化生成
 */
class UserPrincipal {
    private String tokenId;
    private Date expiresAt;
    
    private Integer uId;
    private String client;
    private TokenAuthRole role;

    public boolean hasAnyRoles(List<AuthRole> roles) {
        return roles.contains(this.role);
    }
}

class DGStudentAdmissionVerifyPrincipal extends UserPrincipal {
    private int schoolId;
}

class CommonUserPrincipal extends UserPrincipal {
    /**
     * 用户作为common user的所属组织
     */
    private List<UserOrganization> orgs;
    
    /**
     * 用户作为common user的具体角色
     * 需要注意角色继承关系，如果用户是DGTeacher, 则一定也是Teacher, DGTeacher和Teacher两个角色都应该在这个list里
     */
    private List<CommonUserConcreteRole> concreteRoles;

    @Override
    public boolean hasAnyRoles(List<AuthRole> roles) {
        return super.hasAnyRoles(roles) || hasSameRoles(this.concreteRoles, roles);
    }

    
    public UserOrganization getOrg(int orgId){
        return orgs.findById(orgId);
    }
    
    /**
     * 返回用户所有CommonUserConcreteRole，需要注意的是CommonUserConcreteRole之间是有继承关系的，且最终结果不能重复
     * 不同orgs值举例：
     * 1. [{id: 1, type: dg, roles:[2, 4]}] 需返回 Teacher(11), DGTeacher(111)
     * 2. [{id: 1, type: dg, roles:[2, 4]}, {id: 2, type: dg, roles:[3]}] 需返回 Teacher(11), DGTeacher(111), DGCenterTeacher(1111)
     * 3. [{id: 1, type: dg, roles:[2, 4]}, {id: 234, type: qsdx, roles:[1]}] 需返回 Teacher(11), DGTeacher(111), Student(12), QSDXStudent(122)
     * 4. [{id: 2320, type: tp, roles: [2]}] 需返回 Teacher(11)
     * @return 返回用户所有CommonUserConcreteRole
     */
    private List<CommonUserConcreteRole> calculateConcreteRoles(){
        HashSet<CommonUserConcreteRole> roles = new HashSet<>();
        for (UserOrganization org : this.orgs) {
            roles.addAll(org.getRoles());
        }
        return roles;
    }
}
```

```java
/**
 * 主要负责token生成与有效性校验。
 */
class AuthTokenManager {

    /**
     * 持久化存储，用于server主动控制token有效性
     */
    private UserAuthTokenStorage userAuthTokenStorage;

    public AuthTokenManager(UserAuthTokenStorage storageService) {
        this.userAuthTokenStorage = storageService;
    }

    public String genAnonymousToken(ClientTypeEnum client, int userId) {
        return genToken(client, userId, AuthRole.AnonymousUser, null, false);
    }

    public String genWeekPwdUserToken(ClientTypeEnum client, int userId) {
        return genToken(client, userId, AuthRole.WeekPwdUser, null, true);
    }

    public String genCommonUserToken(ClientTypeEnum client, int userId, List<UserOrganization> orgs) {
        Map<String, Object> dynamicClaims = new HashMap<>();
        dynamicClaims.put("orgs", orgs);
        
        return genToken(client, userId, AuthRole.CommonUser, dynamicClaims, true);
    }
    
    private String genToken(String keyId, ClientTypeEnum client, Integer userId, AuthRole role, Map<String, Object> dynamicClaims, boolean shouldPersistent) {
        long timeout = 30 * 24 * 3600000L; // 30days
        Algorithm algorithm = Algorithm.HMAC256(getAccessTokenSecret());
        String token = JWT.create()
                .withJWTId(IDGenerator.getJWTID())
                .withClaim("client", client)
                .withClaim("uId", userId)
                .withClaim("role", role)
                .withExpiresAt(new Date(System.currentTimeMillis() + timeout))
                .withClaims(dynamicClaims)
                .sign(algorithm);
        
        if (shouldPersistent){
            this.userAuthTokenStorage.updateTokenStatus(client, userId, TokenStatusEnum.DISABLE);
            
            UserAuthToken tokenInfo = new UserAuthToken(client, userId, token, TokenStatusEnum.OK);
            this.userAuthTokenStorage.add(token);
        }

        return token;
    }

    /**
     * 校验token，先判断token签名是否正确，再判断token是否依然有效
     * @param token token
     * @return 1.OK 2.TOKEN_EXPIRE 3.TOKEN_SIGN_INVALID 4.TOKEN_DISABLED_BY_OTHER_LOGIN 5.TOKEN_DISABLED_BY_ADMIN
     */
    public GenericResult<UserPrincipal> authentication(String token) {
        String token = getToken(request);

        GenericResult<UserPrincipal> result = validateTokenContent(token);
        if (result.isOk()) {
            Token token = this.userAuthTokenStorage.getToken(token.tokenId);
            if (token.isNotOk()) {
                result.setHrByTokenStatus(token.status)
            }
        }

        return result
    }
}
```

#### 角色权限配置与授权实现
授权逻辑在filter实现，server配置好各角色/用户的权限，请求到来时，由filter进行拦截并校验。角色-权限配置有两种常见思路：

1. 按功能配置可用角色，授权时，根据`request.url`找到其对应配置，判断是否有权限，即Function Based Config
2. 按角色配置可用功能，授权时，根据`request.token.role`配置找到对应配置，判断是否有权限，即Role Based Config

API项目的接口都是按module组织的，每个module的接口具有自己的prefix，且有对应的研发小组负责，同时API项目的每个接口所允许访问的角色是比较广泛与多变的，
所以选择使用Function Based Config方式会让角色-权限配置更简单、易维护。

web项目的接口基本是按角色组织的，比如各项目基本都是/admin/，/student/两种prefix的接口，同时接口允许访问的角色比较单一、固定，
而且老师的权限是数据库动态配置的，不能按功能配置可用角色，所以选择使用Role Based Config。

下面介绍具体实现：


##### API项目

下面是认证授权入口类`AuthFilter`，大致逻辑如下：
```java
class AuthFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
        AuthorizationRule authorizationRule = AuthorizationRuleManager.getAuthorizationRule(request.getPath());
        if (authorizationRule.authFree()){
            chain.doFilter(request, response);
            return;
        }
        
        GenericResult<UserPrincipal> authTokenResult = AuthTokenManager.authentication(request.getToken());
        if (authTokenResult.isNotOk()) {
            authenticationFailed(response, authTokenResult.getHr());
            return;
        }

        UserPrincipal principal = authTokenResult.getData();
        boolean hasPermission = authorizationRule.allow(principal);

        if (!hasPermission) {
            authorizationFailed(response);
            return;
        }

        chain.doFilter(request, response);
    }
}
```

其中`AuthorizationRuleManager` 提供一个查询url权限的接口，真实的权限配置在各个`ModuleAuthorizationRuleManager`
```java
class AuthorizationRuleManager {
    private final static List<ModuleAuthorizationRuleManager> ALL_MODULE_RULE_MANAGERS = new ArrayList<>();

    static {
        ALL_MODULE_RULE_MANAGERS.add(AccountAuthorizationRuleManager.instance());
    }

    public static AuthorizationRule getAuthorizationRule(String requestPath) {

        // 举例：requestPath="/account/login", modulePrefix="/account", requestFunction="/login"
        String modulePrefix = requestPath.substring(0, firstSlash);
        String requestFunction = requestPath.replace(requestPath, modulePrefix);

        ModuleAuthorizationRuleManager moduleRuleManager = getModuleRuleManager(modulePrefix);

        return moduleRuleManager.getAuthorizationRule(requestFunction);
    }

    private static ModuleAuthorizationRuleManager getModuleRuleManager(String modulePrefix){
        for (ModuleAuthorizationRuleManager ruleManager : ALL_MODULE_RULE_MANAGERS) {
            if (modulePrefix.equals(ruleManager.getModulePrefix())) {
                return ruleManager;
            }
        }

        return DefaultFilterRuleManager.instance();
    }
}

class AuthorizationRule {
    private boolean isAuthFree;
    private List<AuthRole> allowRoles = new ArrayList<>();

    public boolean allow(UserPrincipal principal){
        return isAuthFree || principal.hasAnyRoles(allowRoles);
    }
}
```

api项目中每个module维护一个校验规则类，即Function Based Config。下面以account module为例：

```java
abstract class ModuleAuthorizationRuleManager {
    private final Map<String, AuthorizationRule> pathToAuthorizationRuleMap;

    protected ModuleAuthorizationRuleManager() {
        this.pathToAuthorizationRuleMap = config(new FackRequest()).build();
    }

    public AuthorizationRule getAuthorizationRule(String functionPath) {
        return pathToAuthorizationRuleMap.get(functionPath);
    }

    abstract String getModulePrefix();

    abstract void config(FakeRequest request);
}

class AccountAuthorizationRuleManager extends ModuleAuthorizationRuleManager {

    @Override
    protected void config(FakeRequest request) {
        request.anyMatch("/createAnonymous").authFree()
                .anyMatch({"/createUser", "/login"}).allow(TokenAuthRole.AnonymousUser)
                .anyMatch("/info", "/getValidationCode").allow(TokenAuthRole.AnonymousUser, TokenAuthRole.WeakPwdUser, TokenAuthRole.NeedBindPhoneUser, TokenAuthRole.CommonUser)
                .anyMatch("/bindIdentifyInfo", "/resetPassword").allow(TokenAuthRole.WeakPwdUser, TokenAuthRole.NeedBindPhoneUser, TokenAuthRole.CommonUser)
                .anyMatch("/update").allow(TokenAuthRole.CommonUser)
                .anyMatch("/queryBalance").allow(TokenAuthRole.AnonymousUser, TokenAuthRole.CommonUser)
                .anyMatch("/confirmStudentStatusInfo").allow(CommonUserConcreteRole.DGStudent)
                .aynMatch("/deleteUser").allow(CommonUserConcreteRole.QSDXStudent)
                .anyMatch("/loginByCode").allow(TokenAuthRole.WeakPwdUser, TokenAuthRole.NeedBindPhoneUser, TokenAuthRole.CommonUser);
    }

    @Override
    public String getModulePrefix() {
        return "/account";
    }

    public AccountAuthorizationRuleManager instance(){
        return singleton instance;
    }
}

class DefaultFilterRuleManager extends ModuleAuthorizationRuleManager {
    @Override
    protected void config(FakeRequest request) {
        request.anyRequest().denyAll();
    }

    @Override
    public String getModulePrefix() {
        return null;
    }

    public DefaultFilterRuleManager instance(){
        return singleton instance;
    }
}
```

##### web项目

下面是认证授权入口类`AuthFilter`，大致逻辑如下：
```java
class AuthFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
        String servletPath = ((HttpServletRequest) request).getServletPath();
        
        if (AuthFreeFilterRule.instance().allow(servletPath)){
            chain.doFilter(request, response);
            return;
        }

        GenericResult<School> schoolResult = SchoolManager.instance().getBySymbol(collegeSymbol);
        if (!schoolResult.isValid()) {
            ((HttpServletResponse) response).setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        
        int categoryType = schoolResult.getData().getSchoolCategoryType();
        if (categoryType == SchoolCategoryType.PEIXUN.id()) {
            ((HttpServletResponse) response).sendRedirect(AppSettingManager.instance().peixunWebHost() + "/" + collegeSymbol + "/Home");
            return;
        } else if (categoryType == SchoolCategoryType.GAOZHI.id()) {
            ((HttpServletResponse) response).sendRedirect(AppSettingManager.instance().gaozhiWebHost() + "/" + collegeSymbol + "/Home");
            return;
        } else if (categoryType == SchoolCategoryType.UNKNOWN.id()) {
            ((HttpServletResponse) response).sendRedirect(AppSettingManager.instance().homeWebHost());
            return;
        }
      
        GenericResult<UserPrincipal> authTokenResult = AuthTokenManager.authentication(request.getToken());
        if (authTokenResult.isNotOk()) {
            // 认证失败，重定向到学校首页，并提示token无效原因
            authenticationFailed(response, authTokenResult.getHr());
            return;
        }

        UserPrincipal principal = authTokenResult.getData();

        List<FilterRule> filterRules = FilterRuleManager.getFilterRules(principal, schoolResult.getData.getId());
        for(FilterRule filterRule : filterRules){
            if (filterRule.allow(servletPath)){
                chain.doFilter(request, response);
                return;
            }
        }

        // 授权失败，返回403
        authorizationFailed(response);
    }
}
```

```java
import java.util.HashSet;

/**
 * 授权配置，每个角色实现此接口配置自己的权限规则
 */
interface FilterRule {
    boolean allow(String servletPath);
}

/**
 * 存放该web项目中所有用户都可以访问的资源，比如assets资源
 */
class AuthFreeFilterRule implements FilterRule {

    private static String[] s_allowPaths;

    @Override
    public boolean allow(String servletPath) {
        return urlMathPatterns(servletPath, s_allowPaths)
    }
}

/**
 * 普通用户可以访问资源，比如学校主页等
 *
 * 普通用户 = 本校用户 join 其他学校用户，具体角色关系见 CommonUserConcreteRole
 */
class CommonUserFilterRule implements FilterRule {

    private static String[] s_allowPaths;

    @Override
    public boolean allow(String servletPath) {
        return urlMathPatterns(servletPath, s_allowPaths)
    }
}

/**
 * 老师可以访问的资源
 * 
 * 不论是教务老师、教学老师，抑或是函授站老师，其可访问模块的权限都是动态配置在数据库中的，所以此处需要先查询存储，以确定当前老师权限
 */
class TeacherFilterRule implements FilterRule {
    
    private int schoolId;
    private UserOrganization org;

    TeacherFilterRule(int schoolId, UserOrganization org){
        this.schoolId = schoolId;
        this.org = org;
    }
    
    @Override
    public boolean allow(String servletPath) {
        
        // should cached by local & memcached
        List<Module> modules = getTeacherModuleManager(this.schoolId).getByTeacher(this.org.ouid);

        // find all permitted paths to the teacher
        List<String> allowPaths = findPathsByModules(modules, this.org.roles);
        return urlMathPatterns(servletPath, allowPaths);
    }
}
```

```java
class FilterRuleManager {
    
    public static List<FilterRule> getFilterRules(UserPrincipal principal, int currentSchoolId) {
        List<FilterRule> result = new ArrayList<>();
        
        if (principal.role == TokenAuthRole.AnonymousUser) {
            result.add(AnonymousUserFilterRule.instance());
        } else if (principal.role == TokenAuthRole.WeekPwdUser) {
            result.add(WeekPwdUserFilterRule.instance());
        } else if (principal.role == TokenAuthRole.CommonUser) {
            result.add(CommonUserFilterRule.instance());

            CommonUserPrincipla commonUserPrincipal = (CommonUserPrincipla) principal;
            UserOrganization org = commonUserPrincipal.getOrg(currentSchoolId);
            if (org == null) {
                return result;
            }
            
            if (isTeacher(org.roles)) {
                result.add(new TeacherFilterRule(currentSchoolId, org));
            }else if(isStudent(org.roles)){
                if (isExamPlatform(org.type)){
                    result.add(StudentExamineeFilterRule.instance());
                }else {
                    Student student = getStudentManager(currentSchoolId).getById(org.ouid);
                    result.add(getStudentFilterRuleByStudyStatus(student.getStudyStatus()));
                }
            }
        }
   
        return result;
    }
}
```

> TODO
> * user_school.user_role 去掉预报名学生/超级管理员/录课老师
> * global_user.user_type 去掉1&2
> * global_center_user.role 去掉0&3&4
> * 各web项目建立url规范，url中相同模块的接口应具有一致的prefix，比如/{symbol}/{admin|student}/{module}/{function}
> * 各web项目，/{symbol}/svc/.*等应受角色限制的接口移到对应角色路径下
> * web项目，不再依赖identity cookie做认证授权，只依赖token


#### token主动失效
发生以下三种事件时，要将token主动置为失效

* 用户origination数据发生变化
* 用户被删除
* 用户账号异地登陆

为了能够将存放在client的token置为失效，需要server做出一些stateless方面的牺牲，保存token信息，实现如下：

##### 数据库设计
```sql
CREATE TABLE user_auth_token (
    id int(11) NOT NULL AUTO_INCREMENT,
    user_id int(11) NOT NULL,
    client int(2) NOT NULL,
    token_id varchar(128) NOT NULL,
    status int(2) NOT NULL COMMENT '1有效 2异地登陆导致无效 3被主动置为失效',
    created_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

##### 实现类
由于每次请求到来server都要查询token状态，数据库查询会有较大压力。这里使用本地缓存（1分钟） + memcached两级缓存（2小时）方式提高查询性能，牺牲一点失效实时性。

```java
public class UserAuthTokenManager {

    public void addToken(UserAuthToken token){
        dal.create(token);
    }

    public UserAuthToken getToken(String tokenId){
        UserAuthToken cachedToken = cacheImpl.get(getTokenCacheKey(tokenId));
        if (cachedToken != null){
            return cachedToken;
        }

        cachedToken = dal.getByTokenId(tokenId);
        cacheImpl.put(getTokenCacheKey(tokenId), cachedToken);
        return cachedToken;
    }

    /**
     * 将符合条件的token状态置为status
     * @param userId 必填
     * @param client 可空
     * @param status 必填
     */
    public void updateTokenStatus(int userId, Integer client, TokenStatusEnum status){
        List<UserAuthTokenData> tokensList = dal.search(userId, client, TokenStatusEnum.OK);

        tokensList.setStatus(status);
        dal.batchUpdate(tokensList);

        rmCache(tokensList);
    }

    private String getTokenCacheKey(String tokenId){
        return "TOKEN_BY_ID_" + tokenId;
    }
}
```

### 3、调用方提供SIGN
#### CASE1：我方作为用户，接入三方服务
比如系统接入微信/支付宝/银行/短信平台/CDN平台，在和这些三方系统通信时（包括系统调用第三方接口，和第三方回调系统接口），通信的双方需要对收到的请求进行校验，保证通信内容的可信性。

这种场景下的接口，需要遵循第三方要求的规范，我们没有什么设计空间。业界对于此种场景的接口，一般使用共享私钥+HMAC签名的方式实现认证授权。

我们在实现时需要注意的一点是，共享私钥和签名算法***必须存放在server端***，不能在client端。

#### CASE2：我方作为服务提供方，调用方是外部系统
比如提供成绩查询接口供学校教务系统调用；提供课件查询接口供学校教学系统调用等

此类场景中，作为服务提供方，我们设计接口规范，需要确保请求确实是来自指定外部系统，且请求内容是没有被篡改的。实现思路可以借鉴`CASE1`，具体实现如下：
1. 为每个第三方分配唯一的`APPID`和`APPSECRET`
2. server设置每个`APPID`允许调用的接口，允许发起调用的IP白名单
3. 第三方调用接口时，使用`APPSECRET`对请求内容进行`HmacSHA256`签名，待签名内容除业务参数外，还需带有`appId`, `url`, `timestamp`
4. server校验该`APPID`的水平权限，防止越权攻击，比如A学校不能请求B学校的资源

##### 数据库设计
```sql
CREATE TABLE open_auth_setting (
    id int(11) NOT NULL AUTO_INCREMENT,
    app_id varchar(20) DEFAULT NULL,
    app_secret varchar(512) NOT NULL,
    app_organization_id int(11) NULL COMMENT '该APPID对应的青书学堂组织，比如学校，用来做水平权限校验，可以为空',
    service varchar(20) NOT NULL COMMENT '授权该APPID可以访问的服务，一个appID只能授权访问一个service',
    allow_ips TEXT DEFAULT NULL,
    desc varchar(100) DEFAULT NULL,
    created_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY unq_app_id (app_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE open_auth_service_function (
    id int(11) NOT NULL AUTO_INCREMENT,
    service varchar(20) NOT NULL COMMENT '比如 LOGIN_SERVICE, SCORE_SERVICE, COURSEWARE_SERVICE',
    function_name varchar(512) NOT NULL COMMENT 'service对应的具体服务',
    created_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

##### 授权实现
将验证sign&授权的逻辑实现为公共类库，在各项目中共用，大致算法如下：
```java
class RequestAuthManager() {

    public boolean isSignValid(Request request){
        String text = request.getTextToSign(); // 除sign外所有请求参数按字母顺序排列，以`application/x-www-form-urlencoded`格式生成待签名字符串
        String sign = HMAC256(text, getAppSecret());

        return sign.equals(request.getSign());
    }

    public boolean hasPermission(Request request){
        return ipAllowed(request.getIp())
                && functionAllowed(request.getPath())
                && orgnazationAllowed(request.getSchoolId());
    }
}
```


## 安全限制
对于一些敏感接口，只使用认证&授权机制确保安全是不够的，往往还需要结合以下几种安全限制：
* NeedValidateWhenTooManyRequests，请求过于频繁时，需要进行图片验证码认证，证明其不是机器人，实现如下：
* TempDeniedWhenTooManyError，用户调用某一接口错误过多时，server主动拒绝服务一段时间，适用于登陆、输入验证码等接口

使用场景举例：
1. /account/login 需要结合TempDeniedWhenTooManyError，防止爆破攻击
2. /x/uploadImage 需要结合NeedValidateWhenTooManyRequests，防护接口恶意调用产生巨大cdn服务费用

### 接口设计
```java
@RestController
class Controller {
    
    @PostMapping(value = "/account/login")
    @TempDeniedWhenTooManyError(by={"#reqest.name","#request.phone"}, happened=5, inSec=60, deniedSec=1800)
    public GenericJsonResult<LoginResponse> login(HttpServletRequest httpRequest, @RequestBody LoginRequest request){
        
    }

    @PostMapping(value = "/x/uploadImage")
    @NeedValidateWhenTooManyRequests(by=QSLimitBy.AuthenticationUser, happened=10, inSec=60)
    public GenericJsonResult<LoginResponse> uploadImage(HttpServletRequest httpRequest, @RequestBody UploadImageRequest request){
    }
}
```
### 实现


## 安全保障
### 一致性（Consistency）
数据状态一致，允许最终一致，包括依赖用户手动重试达到的最终一致性。

### 幂等性（Idempotence）
对于已成功的调用，再次调用时直接返回成功，不对系统产生任何影响，防止重放请求产生问题

## 其他特殊场景安全设计
### createAnonymous
**TODO:** 设计安全机制，防止被恶意攻击


## 现有接口梳理

根据各接口功能特点及所需安全等级，在现实接口时，选择`一或多种认证授权策略` + `0或多种访问限制策略`，一起保证接口安全性。此处梳理处系统已有各接口应有的安全实现：

### API项目
#### account
* /createAnonymous              特定场景设计
* /createUser                   anonymous + 口令 + TempDeniedWhenTooManyError
* /login                        anonymous + 口令 + TempDeniedWhenTooManyError
* /info                         (anonymous+pwdUser+bindPhoneUser+CommonUser)
* /resetPassword                (pwdUser+bindPhoneUser+CommonUser) + 口令 + TempDeniedWhenTooManyError
* /update                       CommonUser
* /queryBalance                 (anonymous+CommonUser)
* /getValidationCode            口令 + TempDeniedWhenTooManyError
* /bindIdentifyInfo             (pwdUser+bindPhoneUser+CommonUser) + 口令 + TempDeniedWhenTooManyError
* /confirmStudentStatusInfo     DGStudent
* /deleteUser                   QSDXStudent + 口令 + TempDeniedWhenTooManyError
* /loginByCode                  (pwdUser+bindPhoneUser+CommonUser)

#### purchase
* /getPurchaserInfo         AuthFree
* /history                  anonymous
* /getOffers                anonymous
* /purchase                 anonymous
* /getTuitionDetail         DGStudent
* /refund                   QSDXStudent
* /callback                 放到内网
* /newCallback              放到内网

#### catalog
#### behavior
#### certificateExam
#### chatroom
#### courseware
#### dc
#### english
#### forum
#### information
#### learnPlan
#### quiz
* /quiz/examIdentity              放到内网

#### resource
#### reward
#### schedule
* /schedule/subscribeCallBack     放到内网

#### score
#### teacher
#### teacherPlatform
#### tuition
* /tuition/{schoolSymbol:[a-z]+}/{platform:[a-z]+}/getTuitionPage       AuthFree
* /tuition/{schoolSymbol:[a-z]+}/{platform:[a-z]+}/getUserPaymentInfo   口令 + TempDeniedWhenTooManyError
* /tuition/{schoolSymbol:[a-z]+}/{platform:[a-z]+}/payResult            调用方提供SIGN + 一致性、幂等性
* /tuition/{schoolSymbol:[a-z]+}/{platform:[a-z]+}/getPayResult         调用方提供SIGN + 一致性、幂等性
* /tuition/{schoolSymbol:[a-z]+}/{platform:[a-z]+}/createOrder          调用方提供SIGN + 一致性、幂等性

#### admission
* /admission/validateStudent       口令 + TempDeniedWhenTooManyError

#### x
* /x/thirdPartyCallback     调用方提供SIGN + 一致性、幂等性
* /x/pptTransformCall       调用方提供SIGN + 一致性、幂等性
* /x/videoTransformCall     调用方提供SIGN + 一致性、幂等性
* /x/checkAppUpdates        AuthFree
* /x/getHelpFiles           ALL ROLES
* /x/quickJoinClass         口令 + TempDeniedWhenTooManyError
* /x/removeCache    

#### yxk


### HOME项目
#### AuthFree
* /
* /Logout
* /Download
* /login                 口令 + TempDeniedWhenTooManyError
* /validate等            口令 + TempDeniedWhenTooManyError

#### third
* /open/.*              调用方提供sign

#### CommonUser
* /userSchool          


### DEGREE项目

### 高职项目

### 培训项目

### 教师平台项目

### 函授站项目

